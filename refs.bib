% This file was created with JabRef 2.9.2.
% Encoding: UTF8

@INPROCEEDINGS{Biggerstaff1993ICSE,
  author = {Ted J. Biggerstaff and Bharat G. Mitbander and Dallas Webster},
  title = {The Concept Assignment Problem in Program Understanding},
  booktitle = {Proc. 15th Int'l Conf. on Software Engineering (ICSE~'93)},
  year = {1993},
  pages = {482--498},
  abstract = {A person understands a program because they are able to relate the
	structures of the program and its environment to their human oriented
	conceptual knowledge about the world. The problem of discovering
	individual human oriented concepts and assigning them to their implementation
	oriented counterparts for a given a program is the concept assignment
	problem. We will argue that the solution to this problem requires
	methods that have a strong plausible reasoning component. We will
	illustrate these ideas through example scenarios using an existing
	design recovery system called DESIRE. Finally, we will evaluate DESIRE
	based on its usage on real-world problems over the years.},
  doi = {10.1109/ICSE.1993.346017},
}

@ARTICLE{Brooks1983IJMMS,
  author = {Ruven Brooks},
  title = {Towards a Theory of the Comprehension of Computer Programs},
  journal = {Int. J. Man-Mach. Stud.},
  year = {1983},
  volume = {18},
  pages = {543--554},
  number = {6},
  doi = {10.1016/S0020-7373(83)80031-5},
}

@ARTICLE{Gilmore1984IntJManMachStud,
  author = {Gilmore, D J. and Green, T R.G.},
  title = {Comprehension and Recall of Miniature Programs},
  journal = {Int. J. Man-Mach. Stud.},
  year = {1984},
  volume = {21},
  pages = {31--48},
  number = {1},
  month = oct,
  abstract = {Differences in the comprehensibility of programming notations can
	arise because their syntax can make them cognitively unwieldy in
	a generalized way (Mayer, 1976), because all notations are translated
	into the same “mental language“ but some are easier to translate
	than others (Shneiderman & Mayer, 1979), or because the mental operations
	demanded by certain tasks are harder in some notations than in others
	(Green, 1977). The first two hypotheses predict that the relative
	comprehensibility of two notations will be consistent across all
	tasks, whereas the mental operations hypothesis suggests that particular
	notations may be best suited to particular tasks. The present experiment
	used four notations and 40 non-programmers to test these hypotheses.
	Two of the notations were procedural and two were declarative, and
	one of each pair contained cues to declarative or procedural information,
	respectively. Different types of comprehension question were used
	(“sequential“ and “circumstantial“); a mental operations analysis
	predicted that procedural languages would be “matched” with sequential
	questions, and declarative languages with circumstantial questions.
	Questions were answered first from the printed text, and then from
	recall. Subjects performed best on “matched pairs” of tasks and languages.
	Perceptually-based cues improved the performance on “unmatched pairs”
	better than non-perceptual cues when answering from the text, and
	both types of cues improved performance on “unmatched pairs” in the
	recall stage. These results support the mental operations explanation.
	They also show that the mental representation of a program preserves
	some features of the original notation; a comprehended program is
	not stored in a uniform “mental language”.},
  acmid = {1810},
  address = {London, UK, UK},
  doi = {10.1016/S0020-7373(84)80037-1},
  issn = {0020-7373},
  issue_date = {July 1984},
  numpages = {18},
  publisher = {Academic Press Ltd.},
  url = {http://dx.doi.org/10.1016/S0020-7373(84)80037-1}
}

@INPROCEEDINGS{Ko2006VLHCC,
  author = {Ko, Andrew J. and Myers, Brad A. and Chau, Duen Horng},
  title = {A Linguistic Analysis of How People Describe Software Problems},
  booktitle = {Proceedings of the Visual Languages and Human-Centric Computing},
  year = {2006},
  pages = {127--134},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  abstract = {There is little understanding of how people describe software problems,
	but a variety of tools solicit, manage, and analyze these descriptions
	in order to streamline software development. To inform the design
	of these tools and generate ideas for new ones, an study of nearly
	200,000 bug report titles was performed. The titles of the reports
	generally described a software entity or behavior, its inadequacy,
	and an execution context, suggesting new designs for more structured
	report forms. About 95% of noun phrases referred to visible software
	entities, physical devices, or user actions, suggesting the feasibility
	of allowing users to select these entities in debuggers and other
	tools. Also, the structure of the titles exhibited sufficient regularity
	to parse with an accuracy of 89%, enabling a number of new automated
	analyses. These findings and others have many implications for tool
	design and software engineering.},
  acmid = {1174667},
  doi = {10.1109/VLHCC.2006.3},
  isbn = {0-7695-2586-5},
  numpages = {8},
  url = {http://dl.acm.org/citation.cfm?id=1174509.1174667}
}

@ARTICLE{Ko2006TSE,
  author = {Andrew J. Ko and Brad A. Myers and Michael J. Coblenz and Htet Htet
	Aung},
  title = {An Exploratory Study of How Developers Seek, Relate, and Collect
	Relevant Information during Software Maintenance Tasks},
  journal = {IEEE Trans. Softw. Eng.},
  year = {2006},
  volume = {32},
  pages = {971--987},
  number = {12},
  abstract = {Much of software developers' time is spent understanding unfamiliar
	code. To better understand how developers gain this understanding
	and how software development environments might be involved, a study
	was performed in which developers were given an unfamiliar program
	and asked to work on two debugging tasks and three enhancement tasks
	for 70 minutes. The study found that developers interleaved three
	activities. They began by searching for relevant code both manually
	and using search tools; however, they based their searches on limited
	and misrepresentative cues in the code, environment, and executing
	program, often leading to failed searches. When developers found
	relevant code, they followed its incoming and outgoing dependencies,
	often returning to it and navigating its other dependencies; while
	doing so, however, Eclipse's navigational tools caused significant
	overhead. Developers collected code and other information that they
	believed would be necessary to edit, duplicate, or otherwise refer
	to later by encoding it in the interactive state of Eclipse's package
	explorer, file tabs, and scroll bars. However, developers lost track
	of relevant code as these interfaces were used for other tasks, and
	developers were forced to find it again. These issues caused developers
	to spend, on average, 35 percent of their time performing the mechanics
	of navigation within and between source files. These observations
	suggest a new model of program understanding grounded in theories
	of information foraging and suggest ideas for tools that help developers
	seek, relate, and collect information in a more effective and explicit
	manner.},
  doi = {10.1109/TSE.2006.116},
}

@INPROCEEDINGS{LaToza2007FSE,
  author = {Thomas D. LaToza and David Garlan and James D. Herbsleb and Brad
	A. Myers},
  title = {Program Comprehension as Fact Finding},
  booktitle = {Proc. 6th Joint Meeting European Software Eng. Conf. and ACM SIGSOFT
	Symp. Foundations Software Eng. (ESEC/FSE~2007)},
  year = {2007},
  abstract = {Little is known about how developers think about design during code
	modification tasks or how experienced developers' design knowledge
	helps them work more effectively. We performed a lab study in which
	thirteen developers worked for 3 hours understanding the design of
	a 54 KLOC open source application. Participants had from 0 to 10.5
	years of industry experience and were grouped into three "experts"
	and ten "novices." We observed that participants spent their time
	seeking, learning, critiquing, explaining, proposing, and implementing
	facts about the code such as "getFoldLevel has effects". These facts
	served numerous roles, such as suggesting changes, constraining changes,
	and predicting the amount of additional investigation necessary to
	make a change. Differences between experts and novices included that
	the experts explained the root cause of the design problem and made
	changes to address it, while novice changes addressed only the symptoms.
	Experts did not read more methods but also did not visit some methods
	novices wasted time understanding. Experts talked about code in terms
	of abstractions such as "caching" while novices more often described
	code statement by statement. Experts were able to implement a change
	faster than novices. Experts perceived problems novices did not and
	were able to explain facts novices could not. These findings have
	interesting implications for future tools.},
  doi = {10.1145/1287624.1287675},
}

@INPROCEEDINGS{LaToza2010ICSE,
  author = {LaToza, Thomas D. and Myers, Brad A.},
  title = {Developers ask reachability questions},
  booktitle = {Proc. 32nd ACM/IEEE Int'l Conf. Software Eng. (ICSE~'10)},
  year = {2010},
  series = {ICSE '10},
  pages = {185--194},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {A reachability question is a search across feasible paths through
	a program for target statements matching search criteria. In three
	separate studies, we found that reachability questions are common
	and often time consuming to answer. In the first study, we observed
	13 developers in the lab and found that half of the bugs developers
	inserted were associated with reachability questions. In the second
	study, 460 professional software developers reported asking questions
	that may be answered using reachability questions more than 9 times
	a day, and 82\% rated one or more as at least somewhat hard to answer.
	In the third study, we observed 17 developers in the field and found
	that 9 of the 10 longest activities were associated with reachability
	questions. These findings suggest that answering reachability questions
	is an important source of difficulty understanding large, complex
	codebases.},
  acmid = {1806829},
  doi = {10.1145/1806799.1806829},
  isbn = {978-1-60558-719-6},
  keywords = {code navigation, developer questions, empirical study, program comprehension,
	software maintenance},
  location = {Cape Town, South Africa},
  numpages = {10},
  url = {http://doi.acm.org/10.1145/1806799.1806829}
}

@ARTICLE{Letovsky1987JSS,
  author = {Stanley Letovsky},
  title = {Cognitive Processes in Program Comprehension},
  journal = {J. Syst. Softw.},
  year = {1987},
  volume = {7},
  pages = {325--339},
  number = {4},
  doi = {10.1016/0164-1212(87)90032-X},
}

@ARTICLE{Littman1987JSS,
  author = {David C. Littman and Jeannine Pinto and Stanley Letovsky and Elliot
	Soloway},
  title = {Mental Models and Software Maintenance},
  journal = {J. Syst. Software},
  year = {1987},
  volume = {7},
  pages = {341--355},
  number = {4},
  url = {http://portal.acm.org/citation.cfm?id=28887}
}

@ARTICLE{vonMayrhauser1996TSE,
  author = {Anneliese von Mayrhauser and A. Marie Vans},
  title = {Identification of Dynamic Comprehension Processes During Large Scale
	Maintenance},
  journal = {IEEE Trans. Softw. Eng.},
  year = {1996},
  volume = {22},
  pages = {424--437},
  number = {6},
  abstract = {We present results of observing professional maintenance engineers
	working with industrial code at actual maintenance tasks. Protocol
	analysis is used to explore how code understanding might differ for
	small versus large scale code. The experiment confirms that cognition
	processes work at all levels of abstraction simultaneously as programmers
	build a mental model of the code. Analysis focused on dynamic properties
	and processes of code understanding. Cognition processes emerged
	at three levels of aggregation representing lower and higher level
	strategies of understanding. They show differences in what triggers
	them and how they achieve their goals. Results are useful for defining
	information which maintenance engineers need for their work and for
	documentation and development standards.},
  doi = {10.1109/32.508315},
}

@INPROCEEDINGS{Parnin2010PPIG,
  author = {Parnin, Chris},
  title = {A cognitive neuroscience perspective on memory for programming tasks},
  booktitle = {Proc. 22nd Annu. Meeting Psychology of Programming Interest Group
	(PPIG~2010)},
  year = {2010},
  abstract = {When faced with frequent interruptions and task-switching, programmers
	have difficulty keeping relevant task knowledge in their mind. An
	understanding of how programmers actively manage this knowledge provides
	a foundation for evaluating cognitive theories and building better
	tools. Recently, advances in cognitive neuroscience and brain imaging
	technology has provided new insight into the inner workings of the
	mind; unfortunately, theories such as program understanding have
	not been accordingly advanced. In this paper, we review recent findings
	in cognitive neu- roscience and examine the impacts on our theories
	of how programmers work and the design of programming environments.},
  url = {http://www.ppig.org/papers/22nd-UX-3.pdf}
}

@INPROCEEDINGS{Parnin2012ICPC,
  author = {Chris Parnin and Spencer Rugaber},
  title = {Programmer information needs after memory failure},
  booktitle = {Proc. 20th Int'l Conf. Program Comprehension (ICPC~'12)},
  year = {2012},
  pages = {123--132},
  abstract = {Despite its vast capacity and associative powers, the human brain
	does not deal well with interruptions. Particularly in situations
	where information density is high, such as during a programming task,
	recovering from an interruption requires extensive time and effort.
	Although modern program development environments have begun to recognize
	this problem, none of these tools take into account the brain's structure
	and limitations. In this paper, we present a conceptual framework
	for understanding the strengths and weaknesses of human memory, particularly
	with respect to it ability to deal with work interruptions. The framework
	explains empirical results obtained from experiments in which programmers
	were interrupted while working. Based on the framework, we discuss
	programmer information needs that development tools must satisfy
	and suggest several memory aids such tools could provide. We also
	describe our prototype implementation of these memory aids.},
  doi = {10.1109/ICPC.2012.6240479},
}

@INPROCEEDINGS{Pennington1987,
  author = {Nancy Pennington},
  title = {Comprehension Strategies in Programming},
  booktitle = {Proc. 2nd Workshop Empirical Stud. of Programmers},
  year = {1987},
  pages = {100--113},
  url = {http://portal.acm.org/citation.cfm?id=54975}
}

@ARTICLE{Robillard2004TSE,
  author = {Martin P. Robillard and Wesley Coelho and Gail C. Murphy},
  title = {How Effective Developers Investigate Source Code: An Exploratory
	Study},
  journal = {IEEE Trans. Softw. Eng.},
  year = {2004},
  volume = {30},
  pages = {889--903},
  number = {12},
  abstract = {Prior to performing a software change task, developers must discover
	and understand the subset of the system relevant to the task. Since
	the behavior exhibited by individual developers when investigating
	a software system is influenced by intuition, experience, and skill,
	there is often significant variability in developer effectiveness.
	To understand the factors that contribute to effective program investigation
	behavior, we conducted a study of five developers performing a change
	task on a medium-size open source system. We isolated the factors
	related to effective program investigation behavior by performing
	a detailed qualitative analysis of the program investigation behavior
	of successful and unsuccessful developers. We report on these factors
	as a set of detailed observations, such as evidence of the phenomenon
	of inattention blindness by developers skimming source code. In general,
	our results support the intuitive notion that a methodical and structured
	approach to program investigation is the most effective.},
  doi = {10.1109/TSE.2004.101},
}

@INPROCEEDINGS{Rugaber1995WCRE,
  author = {Spencer Rugaber and Kurt Stirewalt and Linda M. Wills},
  title = {The Interleaving Problem in Program Understanding},
  booktitle = {Proc. 2nd Work. Conf. Reverse Eng. (WCRE~1995)},
  year = {1995},
  pages = {166--175},
  abstract = {One of the factors that can make a program difficult to understand
	is that code responsible for accomplishing more than one purpose
	may be woven together in a single section. We call this interleaving,
	and it may arise either intentionally-for example, in optimizing
	a program, a programmer may use some intermediate result for several
	purposes-or unintentionally, due to patches, quick fixes, or other
	hasty maintenance practices. To understand this phenomenon, we have
	looked at a variety of interleaving instances in actual programs
	and have distilled characteristic features. If the characterization
	proves to be robust then it will enable the design of tools for detection
	of interleavings and the extraction of the individual strands of
	computation.},
  doi = {10.1109/WCRE.1995.514705},
}

@ARTICLE{Shneiderman1979IJCISE,
  author = {Ben Shneiderman and Richard Mayer},
  title = {Syntactic/Semantic Interactions in Programmer Behavior: A Model and
	Experimental Results},
  journal = {Int. J. Comput. Inf. Sci.},
  year = {1979},
  volume = {8},
  pages = {219--238},
  number = {3},
  abstract = {This paper presents a cognitive framework for describing behaviors
	involved in program composition, comprehension, debugging, modification,
	and the acquisition of new programming concepts, skills, and knowledge.
	An information processing model is presented which includes a long-term
	store of semantic and syntactic knowledge, and a working memory in
	which problem solutions are constructed. New experimental evidence
	is presented to support the model of syntactic/semantic interaction.},
  doi = {10.1007/BF00977789},
}

@ARTICLE{Sillito2008TSE,
  author = {Sillito, Jonathan and Murphy, Gail C. and De Volder, Kris},
  title = {Asking and Answering Questions During a Programming Change Task},
  journal = {IEEE Trans. Softw. Eng.},
  year = {2008},
  volume = {34},
  pages = {434--451},
  number = {4},
  abstract = {Little is known about the specific kinds of questions programmers
	ask when evolving a code base and how well existing tools support
	those questions. To better support the activity of programming, answers
	are needed to three broad research questions: (1) what does a programmer
	need to know about a code base when evolving a software system? (2)
	how does a programmer go about finding that information? and (3)
	how well do existing tools support programmer's in answering those
	questions? We undertook two qualitative studies of programmers performing
	change tasks to provide answers to these questions. In this paper,
	we report on an analysis of the data from these two user studies.
	This paper makes three key contributions. The first contribution
	is a catalog of 44 types of questions programmers ask during software
	evolution tasks. The second contribution is a description of the
	observed behavior around answering those questions. The third contribution
	is a description of how existing deployed and proposed tools do,
	and do not, support answering programmers' questions.},
  doi = {10.1109/TSE.2008.26},
}

@INPROCEEDINGS{Storey2005IWPC,
  author = {Storey, Margaret-Anne},
  title = {Theories, Methods, and Tools in Program Comprehension: Past, Present,
	and Future},
  booktitle = {Proc. 13th Int. Workshop Program Comprehension (IWPC~2005)},
  year = {2005},
  pages = {181--191},
  abstract = {Program comprehension research can be characterized by both the theories
	that provide rich explanations about how programmers comprehend software,
	as well as the tools that are used to assist in comprehension tasks.
	During this talk I will review some of the key cognitive theories
	of program comprehension that have emerged over the past thirty years.
	Using these theories as a canvas, I will then explore how tools that
	are popular today have evolved to support program comprehension.
	Specifically, I will discuss how the theories and tools are related
	and reflect on the research methods that were used to construct the
	theories and evaluate the tools. The reviewed theories and tools
	will be further differential according to human characteristics,
	program characteristics, and the context for the various comprehension
	tasks. Finally, I will predict how these characteristics will change
	in the future and speculate on how a number of important research
	directions could lead to improvements in program comprehension tools
	and methods.},
  doi = {10.1109/WPC.2005.38},
  isbn = {0-7695-2254-8}
}

@ARTICLE{Vessey1985IJMMS,
  author = {Iris Vessey},
  title = {Expertise in Debugging Computer Programs: A Process Analysis},
  journal = {Int. J. Man-Mach. Stud.},
  year = {1985},
  volume = {23},
  pages = {459--494},
  number = {5},
  doi = {10.1016/S0020-7373(85)80054-7},
}

